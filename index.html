<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Virtual Desk Assistant - Hiyori</title>

  <!-- CSS íŒŒì¼ ë§í¬ -->
  <link rel="stylesheet" href="renderer/styles/chat.css" />
  <link rel="stylesheet" href="renderer/styles/tasks.css" />
  <link rel="stylesheet" href="renderer/styles/brainstorming.css" />
  <link rel="stylesheet" href="renderer/styles/live2d.css" />

   <!-- ê¸°ë³¸ ìŠ¤íƒ€ì¼ (ë°°ê²½ ì™„ì „ íˆ¬ëª…) -->
   <style>
     html, body {
       margin: 0;
       height: 100%;
       overflow: hidden;
       background: transparent;
       font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
       pointer-events: none; /* ê¸°ë³¸ì ìœ¼ë¡œ í´ë¦­ ë¶ˆê°€ */
     }
     /* ë‚˜ë¨¸ì§€ ìŠ¤íƒ€ì¼ì€ ë³„ë„ CSS íŒŒì¼ë¡œ ë¶„ë¦¬ë¨ */
   </style>
</head>

<body>
  <!-- ëª¨ë“ˆ ìŠ¤í¬ë¦½íŠ¸: ë¨¼ì € ë¡œë“œ (ì „ì—­ìœ¼ë¡œ export) -->
  <script type="module" src="./renderer/chat/chatUI.js"></script>
  <script type="module" src="./renderer/brainstorming/brainstormingService.js"></script>

  <!-- Live2D ìŠ¤í…Œì´ì§€ (ë°°ê²½, ì „ì²´ í™”ë©´) -->
  <div id="stage"></div>
  
  <!-- ì±„íŒ… íŒ¨ë„ (ê³ ì • ìœ„ì¹˜, ìµœìƒìœ„) -->
  <div id="chat-panel">
    <h2>ğŸ’¬ AI ë¹„ì„œ</h2>
    <div id="messages"></div>
    <div id="input-area">
      <input 
        type="text" 
        id="chat-input" 
        placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." 
        autocomplete="off"
      />
      <button id="send-btn">ì „ì†¡</button>
    </div>
  </div>

  <!-- ë¸Œë ˆì¸ìŠ¤í† ë° íŒ¨ë„ (ì˜¤ë¥¸ìª½ ê³ ì •) -->
  <div id="brainstorming-panel">
    <h2>ğŸ’¡ ë¸Œë ˆì¸ìŠ¤í† ë°</h2>
    <div id="bs-content"></div>
    <div id="bs-input-area">
      <input 
        type="text" 
        id="bs-input" 
        placeholder="ì…ë ¥í•˜ì„¸ìš”..." 
        autocomplete="off"
      />
      <button id="bs-submit-btn">ì „ì†¡</button>
    </div>
  </div>

  <script>
    /****************************************************************
     * Electron ipcRenderer ì¤€ë¹„
     * - ë¸Œë¼ìš°ì €ë¡œ ì—´ì—ˆì„ ë•ŒëŠ” requireê°€ ì—†ìœ¼ë‹ˆ try/catch
     ****************************************************************/
    let ipcRenderer = null;
    try {
      // electron í™˜ê²½
      ipcRenderer = require('electron').ipcRenderer;
    } catch (e) {
      console.warn('Electron í™˜ê²½ì´ ì•„ë‹ˆì–´ì„œ ipcRenderer ì—†ìŒ:', e);
    }

    /****************************************************************
     * Activity Monitor (ì¸ë¼ì¸)
     ****************************************************************/
    let activityMonitorCleanup = null;
    
    // Activity Monitor ì„¤ì •
    const ACTIVITY_CONFIG = {
      dev: {
        idleThresholdMs: 3 * 1000,        // 3ì´ˆ (í…ŒìŠ¤íŠ¸ìš©)
        longActiveThresholdMs: 10 * 1000, // 10ì´ˆ (í…ŒìŠ¤íŠ¸ìš©)
        checkIntervalMs: 1000,
      },
      prod: {
        idleThresholdMs: 10 * 60 * 1000,      // 10ë¶„
        longActiveThresholdMs: 50 * 60 * 1000, // 50ë¶„ (5ë¶„ ì´í•˜ íœ´ì‹ í—ˆìš©)
        checkIntervalMs: 5000,                   // 5ì´ˆë§ˆë‹¤ ì²´í¬
      }
    };
    
    function setupActivityMonitor(options) {
      const { mode, onIdle, onLongActive } = options;
      const config = ACTIVITY_CONFIG[mode];
      
      // Activity Monitor ì‹œì‘ (ë¡œê·¸ ì œê±°)
      
      let lastInputAt = Date.now();
      let sessionStartAt = Date.now();
      let isIdle = false;
      let hasNotifiedLongActive = false;
      let checkTimer = null;
      
      function handleUserInput() {
        const now = Date.now();
        lastInputAt = now;
        
        if (isIdle) {
          // í™œë™ ì¬ê°œ
          isIdle = false;
          sessionStartAt = now;
          hasNotifiedLongActive = false;
        }
      }
      
      function checkActivity() {
        const now = Date.now();
        const timeSinceLastInput = now - lastInputAt;
        const currentSessionDuration = now - sessionStartAt;
        
        // Idle ì²´í¬
        if (!isIdle && timeSinceLastInput >= config.idleThresholdMs) {
          isIdle = true;
          // Idle ìƒíƒœ ì§„ì…
          
          try {
            onIdle();
          } catch (error) {
            console.error('âŒ onIdle ì½œë°± ì˜¤ë¥˜:', error);
          }
          
          sessionStartAt = now;
          hasNotifiedLongActive = false;
          return;
        }
        
        // ì¥ì‹œê°„ í™œë™ ì²´í¬
        if (!isIdle && !hasNotifiedLongActive) {
          if (currentSessionDuration >= config.longActiveThresholdMs) {
            hasNotifiedLongActive = true;
            // ì¥ì‹œê°„ í™œë™ ê°ì§€
            
            try {
              onLongActive();
            } catch (error) {
              console.error('âŒ onLongActive ì½œë°± ì˜¤ë¥˜:', error);
            }
          }
        }
        
        // ë””ë²„ê¹… ë¡œê·¸
        if (mode === 'dev' && !isIdle && !hasNotifiedLongActive) {
          const remaining = (config.longActiveThresholdMs - currentSessionDuration) / 1000;
          if (remaining > 0 && Math.floor(remaining) % 2 === 0) {
            // ì¥ì‹œê°„ í™œë™ ì¹´ìš´íŠ¸ë‹¤ìš´ (ë¡œê·¸ ì œê±°)
          }
        }
      }
      
      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      const events = ['mousemove', 'mousedown', 'wheel', 'keydown'];
      events.forEach(eventType => {
        window.addEventListener(eventType, handleUserInput, { passive: true });
      });
      
      // ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      
      // íƒ€ì´ë¨¸ ì‹œì‘
      checkTimer = setInterval(checkActivity, config.checkIntervalMs);
      // ì£¼ê¸°ì  ì²´í¬ ì‹œì‘
      
      // Cleanup í•¨ìˆ˜ ë°˜í™˜
      return function cleanup() {
        // Activity Monitor ì •ë¦¬
        events.forEach(eventType => {
          window.removeEventListener(eventType, handleUserInput);
        });
        if (checkTimer) {
          clearInterval(checkTimer);
        }
      };
    }
    
    function setupActivityMonitorWithMotions() {
      const mode = 'prod'; // ë°°í¬ ëª¨ë“œ: Idle 10ë¶„, ì¥ì‹œê°„ í™œë™ 50ë¶„
      
      activityMonitorCleanup = setupActivityMonitor({
        mode: mode,
        
        onIdle: () => {
          // Idle ì½œë°±: ìºë¦­í„° ëª¨ì…˜
          if (model) {
            model.motion('Idle');
          }
          
          // ì±„íŒ…ì°½ì— ë©”ì‹œì§€ (ëª¨ë“ˆ ë¡œë“œë˜ì—ˆì„ ë•Œë§Œ)
          if (typeof window.addMessage === 'function') {
            window.addMessage('assistant', 'ì¡°ê¸ˆ ì‰¬ê³  ê³„ì‹ ê°€ìš”? ğŸ˜Š');
          } else {
            // ë©”ì‹œì§€ ì¶œë ¥ (ëª¨ë“ˆ ë¯¸ë¡œë“œ ì‹œ)
          }
        },
        
        onLongActive: () => {
          // ì¥ì‹œê°„ í™œë™ ì½œë°±: ìºë¦­í„° ëª¨ì…˜
          if (model) {
            model.motion('Tap@Body');
          }
          
          // ì±„íŒ…ì°½ì— ë©”ì‹œì§€ (ëª¨ë“ˆ ë¡œë“œë˜ì—ˆì„ ë•Œë§Œ)
          if (typeof window.addMessage === 'function') {
            window.addMessage('assistant', 'ì˜¤ë˜ ì¼í•˜ì…¨ë„¤ìš”! ì ê¹ ì¼ì–´ë‚˜ì„œ ìŠ¤íŠ¸ë ˆì¹­ ì–´ë•Œìš”? ğŸ¤¸â€â™€ï¸');
          } else {
            // ë©”ì‹œì§€ ì¶œë ¥ (ëª¨ë“ˆ ë¯¸ë¡œë“œ ì‹œ)
          }
        }
      });
    }

    /****************************************************************
     * ì±„íŒ… ë° ë¸Œë ˆì¸ìŠ¤í† ë° ì´ˆê¸°í™” (ëª¨ë“ˆì—ì„œ ì²˜ë¦¬)
     * - renderer/chat/chatUI.js
     * - renderer/brainstorming/brainstormingService.js
     ****************************************************************/
    let messages = [];
    let isPanelVisible = true;
    let chatPanel = null;
    let messagesContainer = null;
    let chatInput = null;
    let sendBtn = null;
    let isChatPanelInitialized = false; // ğŸ”¥ ì¤‘ë³µ ì´ˆê¸°í™” ë°©ì§€
    
    // ì¶”ì²œ ì—…ë¬´ ì„ íƒ ìƒíƒœ
    let selectedTasks = new Set();
    let currentRecommendation = null; // { owner, target_date, tasks }
    
    // ğŸ”¥ ì¼ì¼ë³´ê³ ì„œ FSM ëª¨ë“œ ìƒíƒœ
    let chatMode = 'normal'; // 'normal' ë˜ëŠ” 'daily_fsm'
    let dailySessionId = null;
    let dailyOwner = 'ê¹€ë³´í—˜'; // TODO: ì‹¤ì œ ë¡œê·¸ì¸ ì‚¬ìš©ìë¡œ ë³€ê²½

    function initChatPanel() {
      // ğŸ”¥ ì´ë¯¸ ì´ˆê¸°í™”ë˜ì—ˆìœ¼ë©´ ë¬´ì‹œ
      if (isChatPanelInitialized) {
        console.log('âš ï¸  ì±„íŒ… íŒ¨ë„ ì´ë¯¸ ì´ˆê¸°í™”ë¨ - ìŠ¤í‚µ');
        return;
      }
      
      console.log('ğŸ’¬ ì±„íŒ… íŒ¨ë„ ì´ˆê¸°í™” ì¤‘...');
      
      chatPanel = document.getElementById('chat-panel');
      messagesContainer = document.getElementById('messages');
      chatInput = document.getElementById('chat-input');
      sendBtn = document.getElementById('send-btn');
      
      if (!chatPanel || !messagesContainer || !chatInput || !sendBtn) {
        console.error('âŒ ì±„íŒ… íŒ¨ë„ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      
      // ì´ˆê¸° ë©”ì‹œì§€ ì¶”ê°€
      addMessage('assistant', 'ì•ˆë…•í•˜ì„¸ìš”! ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”? ğŸ˜Š');
      
      // ğŸ”¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (once ì˜µì…˜ìœ¼ë¡œ ì¤‘ë³µ ë°©ì§€)
      sendBtn.addEventListener('click', handleSendMessage);
      
      chatInput.addEventListener('keydown', handleChatInputKeydown);
      
      // Cmd/Ctrl + Enterë¡œ íŒ¨ë„ í† ê¸€
      window.addEventListener('keydown', handleGlobalKeydown);
      
      isChatPanelInitialized = true; // ğŸ”¥ ì´ˆê¸°í™” ì™„ë£Œ í”Œë˜ê·¸
      console.log('âœ… ì±„íŒ… íŒ¨ë„ ì´ˆê¸°í™” ì™„ë£Œ');
    }

    // ğŸ”¥ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¥¼ ë³„ë„ í•¨ìˆ˜ë¡œ ë¶„ë¦¬ (ì¤‘ë³µ ë“±ë¡ ë°©ì§€)
    function handleChatInputKeydown(e) {
      // í•œê¸€ ì…ë ¥ ì¤‘(composing)ì´ë©´ ë¬´ì‹œ
      if (e.isComposing || e.keyCode === 229) {
        return;
      }
      
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    }

    function handleGlobalKeydown(e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        togglePanel();
      }
    }

    async function handleSendMessage() {
      const text = chatInput.value.trim();
      if (!text) return;
      
      // ğŸ”¥ ì „ì†¡ ì¤‘ì´ë©´ ë¬´ì‹œ (ì¤‘ë³µ ì „ì†¡ ë°©ì§€)
      if (sendBtn.disabled) {
        console.log('âš ï¸  ì´ë¯¸ ì „ì†¡ ì¤‘...');
        return;
      }
      
      addMessage('user', text);
      
      // ğŸ”¥ ì…ë ¥ì°½ ì´ˆê¸°í™” (IME ë¬¸ì œ í•´ê²°)
      chatInput.value = '';
      chatInput.blur(); // í¬ì»¤ìŠ¤ ì œê±°
      setTimeout(() => {
        chatInput.focus(); // ë‹¤ì‹œ í¬ì»¤ìŠ¤
      }, 0);
      
      sendBtn.disabled = true;
      sendBtn.textContent = '...';
      
      try {
        // ğŸ”¥ ëª¨ë“œì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬
        if (chatMode === 'normal' && isDailyStartTrigger(text)) {
          // ì¼ì¼ë³´ê³ ì„œ ì…ë ¥ ì‹œì‘
          await handleDailyStart();
        } else if (chatMode === 'daily_fsm') {
          // FSM ë‹µë³€ ì²˜ë¦¬
          await handleDailyAnswer(text);
        } else {
          // ì¼ë°˜ ì±—ë´‡ ì²˜ë¦¬
          const response = await callChatModule(text);
          
          // ì‘ë‹µ íƒ€ì…ì— ë”°ë¼ ì²˜ë¦¬
          if (response.type === 'task_recommendations') {
            addTaskRecommendations(response.data);
          } else if (response.type === 'error') {
            addMessage('assistant', response.data);
          } else {
            addMessage('assistant', response.data);
          }
        }
      } catch (error) {
        console.error('âŒ ì±„íŒ… ì˜¤ë¥˜:', error);
        addMessage('assistant', 'ì£„ì†¡í•©ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ğŸ˜¢');
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = 'ì „ì†¡';
      }
    }

    function addMessage(role, text) {
      messages.push({ role, text });
      
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${role}`;
      
      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      bubble.textContent = text;
      
      messageDiv.appendChild(bubble);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      console.log(`ğŸ’¬ [${role}]: ${text}`);
    }
    
    // ğŸ”¥ ì¼ì¼ë³´ê³ ì„œ ì…ë ¥ íŠ¸ë¦¬ê±° ê°ì§€
    function isDailyStartTrigger(text) {
      const t = text.replace(/\s+/g, '').toLowerCase();
      return (
        t.includes('ì¼ì¼ë³´ê³ ì„œì…ë ¥í• ë˜') ||
        t.includes('ì¼ì¼ë³´ê³ ì„œì‘ì„±í• ë˜') ||
        t.includes('ì˜¤ëŠ˜ë³´ê³ ì„œì…ë ¥') ||
        t.includes('ì¼ì¼ë³´ê³ ì„œì…ë ¥') ||
        t.includes('ë³´ê³ ì„œì‘ì„±í• ë˜')
      );
    }
    
    // ğŸ”¥ ì¼ì¼ë³´ê³ ì„œ FSM ì‹œì‘
    async function handleDailyStart() {
      console.log('ğŸ“ ì¼ì¼ë³´ê³ ì„œ FSM ì‹œì‘...');
      
      try {
        const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        
        const response = await fetch(`${API_BASE_URL}/daily/start`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            owner: dailyOwner,
            target_date: today
          })
        });
        
        if (!response.ok) {
          throw new Error(`API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('âœ… FSM ì‹œì‘ ì™„ë£Œ:', result);
        
        // FSM ëª¨ë“œë¡œ ì „í™˜
        chatMode = 'daily_fsm';
        dailySessionId = result.session_id;
        
        // Placeholder ë³€ê²½
        chatInput.placeholder = 'í•´ë‹¹ ì‹œê°„ëŒ€ì— í–ˆë˜ ì—…ë¬´ë¥¼ ììœ ë¡­ê²Œ ì ì–´ì£¼ì„¸ìš”...';
        
        // ì²« ì§ˆë¬¸ ì¶œë ¥
        addMessage('assistant', result.question);
        
      } catch (error) {
        console.error('âŒ FSM ì‹œì‘ ì˜¤ë¥˜:', error);
        addMessage('assistant', 'ì¼ì¼ë³´ê³ ì„œë¥¼ ì‹œì‘í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ğŸ˜¢');
      }
    }
    
    // ğŸ”¥ ì¼ì¼ë³´ê³ ì„œ FSM ë‹µë³€ ì²˜ë¦¬
    async function handleDailyAnswer(answer) {
      console.log('ğŸ“ FSM ë‹µë³€ ì „ì†¡:', answer);
      
      try {
        const response = await fetch(`${API_BASE_URL}/daily/answer`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            session_id: dailySessionId,
            answer: answer
          })
        });
        
        if (!response.ok) {
          throw new Error(`API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('âœ… FSM ë‹µë³€ ì²˜ë¦¬ ì™„ë£Œ:', result);
        
        if (result.status === 'finished') {
          // ì™„ë£Œ ì²˜ë¦¬
          addMessage('assistant', result.message || 'ì¼ì¼ë³´ê³ ì„œ ì‘ì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ™Œ');
          
          // ë³´ê³ ì„œ ìš”ì•½ ì¶œë ¥
          if (result.report && result.report.tasks) {
            addReportSummary(result.report);
          }
          
          // ëª¨ë“œ ì´ˆê¸°í™”
          chatMode = 'normal';
          dailySessionId = null;
          chatInput.placeholder = 'ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”...';
          
        } else {
          // ë‹¤ìŒ ì§ˆë¬¸ ì¶œë ¥
          addMessage('assistant', result.question);
        }
        
      } catch (error) {
        console.error('âŒ FSM ë‹µë³€ ì˜¤ë¥˜:', error);
        addMessage('assistant', 'ë‹µë³€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ğŸ˜¢');
      }
    }
    
    // ğŸ”¥ ë³´ê³ ì„œ ìš”ì•½ ì¶œë ¥
    function addReportSummary(report) {
      const summaryLines = [];
      
      // ğŸ“‹ ì˜ˆì • ì—…ë¬´ (plans)
      if (report.plans && report.plans.length > 0) {
        summaryLines.push('ğŸ“‹ ì˜¤ëŠ˜ ì˜ˆì •í–ˆë˜ ì—…ë¬´:');
        report.plans.forEach((plan, index) => {
          summaryLines.push(`  ${index + 1}. ${plan}`);
        });
        summaryLines.push('');
      }
      
      // âœ… ì‹¤ì œ ì™„ë£Œ ì—…ë¬´ (tasks)
      if (report.tasks && report.tasks.length > 0) {
        summaryLines.push('âœ… ì‹¤ì œ ì™„ë£Œí•œ ì—…ë¬´:');
        const tasks = report.tasks.slice(0, 5);
        tasks.forEach((task, index) => {
          const timeInfo = task.time_start && task.time_end ? ` (${task.time_start}~${task.time_end})` : '';
          summaryLines.push(`  ${index + 1}. ${task.title}${timeInfo}`);
        });
        if (report.tasks.length > 5) {
          summaryLines.push(`  ... ì™¸ ${report.tasks.length - 5}ê°œ ì—…ë¬´`);
        }
        summaryLines.push('');
      }
      
      // âš ï¸ ë¯¸ì¢…ê²° ì—…ë¬´ (issues)
      if (report.issues && report.issues.length > 0) {
        summaryLines.push('âš ï¸ ë¯¸ì¢…ê²° ì—…ë¬´:');
        report.issues.forEach((issue, index) => {
          summaryLines.push(`  ${index + 1}. ${issue}`);
        });
        summaryLines.push('');
      }
      
      // ğŸ“ˆ ì™„ë£Œìœ¨
      const metadata = report.metadata || {};
      if (metadata.completion_rate) {
        summaryLines.push(`ğŸ“ˆ ì˜ˆì • ì—…ë¬´ ì™„ë£Œìœ¨: ${metadata.completion_rate}`);
      }
      
      const summaryText = summaryLines.join('\n');
      addMessage('assistant', summaryText);
    }
    
    function addTaskRecommendations(data) {
      const { tasks, summary, owner, target_date } = data;
      
      currentRecommendation = { owner, target_date, tasks };
      selectedTasks.clear();
      
      messages.push({ role: 'assistant', type: 'task_recommendations', data });
      
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message assistant';
      
      const container = document.createElement('div');
      container.className = 'task-recommendations-container';
      
      const summaryDiv = document.createElement('div');
      summaryDiv.className = 'bubble';
      summaryDiv.textContent = summary || 'ì˜¤ëŠ˜ì˜ ì¶”ì²œ ì—…ë¬´ì…ë‹ˆë‹¤!';
      container.appendChild(summaryDiv);
      
      const guideDiv = document.createElement('div');
      guideDiv.className = 'task-guide';
      guideDiv.textContent = 'ğŸ“Œ ìˆ˜í–‰í•  ì—…ë¬´ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš” (2~4ê°œ ê¶Œì¥)';
      container.appendChild(guideDiv);
      
      const cardsContainer = document.createElement('div');
      cardsContainer.className = 'task-cards';
      
      tasks.forEach((task, index) => {
        const card = createTaskCard(task, index);
        cardsContainer.appendChild(card);
      });
      
      container.appendChild(cardsContainer);
      
      const saveButton = document.createElement('button');
      saveButton.className = 'task-save-button';
      saveButton.textContent = 'ì„ íƒ ì™„ë£Œ';
      saveButton.disabled = true;
      saveButton.addEventListener('click', handleSaveSelectedTasks);
      container.appendChild(saveButton);
      
      messageDiv.appendChild(container);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      console.log(`ğŸ¯ ì¶”ì²œ ì—…ë¬´ ${tasks.length}ê°œ í‘œì‹œ`);
    }
    
    function createTaskCard(task, index) {
      const card = document.createElement('div');
      card.className = 'task-card';
      card.dataset.index = index;
      
      const priorityBadge = document.createElement('span');
      priorityBadge.className = `priority-badge priority-${task.priority}`;
      priorityBadge.textContent = {
        'high': 'ë†’ìŒ',
        'medium': 'ë³´í†µ',
        'low': 'ë‚®ìŒ'
      }[task.priority] || 'ë³´í†µ';
      
      const title = document.createElement('div');
      title.className = 'task-title';
      title.textContent = task.title;
      
      const description = document.createElement('div');
      description.className = 'task-description';
      description.textContent = task.description;
      
      const meta = document.createElement('div');
      meta.className = 'task-meta';
      meta.innerHTML = `
        <span class="task-category">ğŸ“ ${task.category}</span>
        <span class="task-time">â° ${task.expected_time}</span>
      `;
      
      card.appendChild(priorityBadge);
      card.appendChild(title);
      card.appendChild(description);
      card.appendChild(meta);
      
      card.addEventListener('click', () => {
        toggleTaskSelection(card, index);
      });
      
      return card;
    }
    
    function toggleTaskSelection(card, index) {
      if (selectedTasks.has(index)) {
        selectedTasks.delete(index);
        card.classList.remove('selected');
      } else {
        selectedTasks.add(index);
        card.classList.add('selected');
      }
      
      const saveButton = card.closest('.task-recommendations-container').querySelector('.task-save-button');
      saveButton.disabled = selectedTasks.size === 0;
      
      console.log(`âœ… ì„ íƒëœ ì—…ë¬´: ${selectedTasks.size}ê°œ`);
    }
    
    async function handleSaveSelectedTasks(event) {
      if (!currentRecommendation || selectedTasks.size === 0) {
        return;
      }
      
      const { owner, target_date, tasks } = currentRecommendation;
      const selectedTasksList = Array.from(selectedTasks).map(index => tasks[index]);
      
      const saveButton = event.target;
      saveButton.disabled = true;
      saveButton.textContent = 'ì €ì¥ ì¤‘...';
      
      try {
        const result = await saveSelectedTasks(owner, target_date, selectedTasksList);
        
        if (result.success) {
          addMessage('assistant', `âœ… ${result.saved_count}ê°œì˜ ì—…ë¬´ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! ê¸ˆì¼ ì§„í–‰ ì—…ë¬´ ì„ íƒì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
          
          selectedTasks.clear();
          currentRecommendation = null;
          
          saveButton.closest('.task-recommendations-container').style.opacity = '0.5';
          saveButton.textContent = 'ì €ì¥ ì™„ë£Œ';
        } else {
          addMessage('assistant', `âŒ ì €ì¥ ì‹¤íŒ¨: ${result.message}`);
          saveButton.disabled = false;
          saveButton.textContent = 'ì„ íƒ ì™„ë£Œ';
        }
      } catch (error) {
        console.error('âŒ ì €ì¥ ì˜¤ë¥˜:', error);
        addMessage('assistant', 'âŒ ì—…ë¬´ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        saveButton.disabled = false;
        saveButton.textContent = 'ì„ íƒ ì™„ë£Œ';
      }
    }

    function togglePanel() {
      isPanelVisible = !isPanelVisible;
      
      if (isPanelVisible) {
        chatPanel.style.display = 'flex';
        console.log('ğŸ‘ï¸ ì±„íŒ… íŒ¨ë„ í‘œì‹œ');
      } else {
        chatPanel.style.display = 'none';
        console.log('ğŸ™ˆ ì±„íŒ… íŒ¨ë„ ìˆ¨ê¹€');
      }
    }
    // ëª¨ë“ˆ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì´ˆê¸°í™”ë¨ (ì•„ë˜ <script type="module"> ì°¸ê³ )

    /****************************************************************
     * ìˆœì°¨ ë¡œë”
     * - ì˜ì¡´ì„± â†’ ì½”ì–´ â†’ í”ŒëŸ¬ê·¸ì¸ ìˆœì„œ ë³´ì¥
     * - CDN ì‹¤íŒ¨ ì‹œ ë‹¤ìŒ í›„ë³´ ìë™ ì‹œë„
     ****************************************************************/
    function loadScript(url) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url;
        s.async = false;               // ë¡œë“œ ìˆœì„œ ë³´ì¥(ì¤‘ìš”)
        s.onload = () => resolve();
        s.onerror = () => { console.error('âŒ ë¡œë“œ ì‹¤íŒ¨:', url); reject(new Error(url)); };
        document.head.appendChild(s);
      });
    }

    // ì „ì—­ì—ì„œ ì“¸ ì°¸ì¡°ìš© (ìŠ¤ì¼€ì¼ ì¡°ì ˆì„ ìœ„í•´)
    let app = null;
    let model = null;

    async function init() {
      try {
        /******** 1) Pixi.js (v6.x) : í”ŒëŸ¬ê·¸ì¸ 0.4.xì™€ í˜¸í™˜ ********/
        const pixiCdn = [
          'https://cdn.jsdelivr.net/npm/pixi.js@6.5.10/dist/browser/pixi.min.js',
          'https://unpkg.com/pixi.js@6.5.10/dist/browser/pixi.min.js'
        ];
        let ok = false;
        for (const url of pixiCdn) {
          try { await loadScript(url); ok = true; break; } catch {}
        }
        if (!ok) throw new Error('Pixi.js ë¡œë“œ ì‹¤íŒ¨');
        // PixiJS ë¡œë“œ ì™„ë£Œ

        /******** 2) Live2D Cubism Core : í”ŒëŸ¬ê·¸ì¸ì´ ì°¸ì¡°í•˜ëŠ” ëŸ°íƒ€ì„ ********/
        const coreCdn = [
          'https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js',
          'https://cubism.live2d.com/sdk-web/bin/live2dcubismcore.min.js'
        ];
        ok = false;
        for (const url of coreCdn) {
          try { await loadScript(url); ok = true; break; } catch {}
        }
        if (!ok) throw new Error('Live2D Cubism Core ë¡œë“œ ì‹¤íŒ¨');
        // Live2DCubismCore ë¡œë“œ ì™„ë£Œ

        /******** 3) pixi-live2d-display (Cubism4 ë¹Œë“œ, 0.4.x) ********/
        const pluginCdn = [
          'https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/cubism4.js',
          'https://unpkg.com/pixi-live2d-display@0.4.0/dist/cubism4.js',
          'https://cdn.jsdelivr.net/gh/guansss/pixi-live2d-display@v0.4.0/dist/cubism4.js'
        ];
        ok = false;
        for (const url of pluginCdn) {
          try {
            await loadScript(url);
            if (window.PIXI?.live2d?.Live2DModel) { ok = true; break; }
          } catch {}
        }
        if (!ok) throw new Error('pixi-live2d-display (cubism4) ë¡œë“œ ì‹¤íŒ¨');

        // Live2D í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ ì™„ë£Œ

        /******** 4) Pixi ì•± & Live2D ëª¨ë¸ ë¡œë“œ ********/
        // ì „ì²´ ìœˆë„ìš° í¬ê¸°ë¡œ ì•± ìƒì„±
        app = new PIXI.Application({ 
          backgroundAlpha: 0,
          width: window.innerWidth,
          height: window.innerHeight,
          resizeTo: window
        });
        
        // stageì— canvas ì¶”ê°€
        const stageContainer = document.getElementById('stage');
        stageContainer.appendChild(app.view);

        const MODEL_URL = 'public/models/hiyori_free_ko/runtime/hiyori_free_t08.model3.json';
        // Stageë¥¼ interactiveë¡œ ì„¤ì •
        app.stage.interactive = true;
        app.stage.hitArea = app.screen;

        model = await PIXI.live2d.Live2DModel.from(MODEL_URL);

         // ë°°ì¹˜: í™”ë©´ ì¤‘ì•™ í•˜ë‹¨ (ë“€ì–¼ ëª¨ë‹ˆí„° ëŒ€ì‘)
         model.anchor.set(0.5, 1);
         model.scale.set(0.18); // ì´ˆê¸° í¬ê¸° (ë¨¸ë¦¬ ì•ˆ ì˜ë¦¬ë„ë¡ ì¶•ì†Œ)
         
         // ìœ„ì¹˜ ì„¤ì • (í™”ë©´ ì¤‘ì•™ ê¸°ì¤€, ìº”ë²„ìŠ¤ í¬ê¸° ê¸°ì¤€)
         const updateModelPosition = () => {
           // ìº”ë²„ìŠ¤ì˜ ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ì•™ ì¡°ê¸ˆ ì˜¤ë¥¸ìª½
           const canvasWidth = app.screen.width;
           const canvasHeight = app.screen.height;
           model.position.set(canvasWidth * 0.75, canvasHeight - 50);
           // ìºë¦­í„° ìœ„ì¹˜ ì„¤ì • ì™„ë£Œ
         };
         updateModelPosition();
         
         // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
         window.addEventListener('resize', () => {
           updateModelPosition();
         });
         
         app.stage.addChild(model);
         // ìºë¦­í„° í™”ë©´ì— ì¶”ê°€ ì™„ë£Œ

         // Document ë ˆë²¨ ë“œë˜ê·¸ êµ¬í˜„
         let isDraggingCharacter = false;
         let dragStartMousePos = null;
         let dragStartModelPos = null;
         
         // ìºë¦­í„° ë°”ìš´ë”© ë°•ìŠ¤ ì²´í¬ í•¨ìˆ˜
         const isMouseOverCharacter = (mouseX, mouseY) => {
           const bounds = model.getBounds();
           const actualWidth = bounds.width * 0.4; // ì¢Œìš° ì¶•ì†Œ
           const widthOffset = (bounds.width - actualWidth) / 2;
           const verticalMargin = bounds.height * 0.05;
           
           return mouseX >= bounds.x + widthOffset && 
                  mouseX <= bounds.x + widthOffset + actualWidth &&
                  mouseY >= bounds.y - verticalMargin && 
                  mouseY <= bounds.y + bounds.height + verticalMargin;
         };
         
         // Document ë ˆë²¨ ì´ë²¤íŠ¸ë¡œ ë“œë˜ê·¸ êµ¬í˜„
         document.addEventListener('mousedown', (e) => {
           if (isMouseOverCharacter(e.clientX, e.clientY)) {
             // ë“œë˜ê·¸ ì‹œì‘
             isDraggingCharacter = true;
             dragStartMousePos = { x: e.clientX, y: e.clientY };
             dragStartModelPos = { x: model.position.x, y: model.position.y };
             e.preventDefault();
           }
         });
         
         document.addEventListener('mousemove', (e) => {
           if (isDraggingCharacter && dragStartMousePos) {
             const dx = e.clientX - dragStartMousePos.x;
             const dy = e.clientY - dragStartMousePos.y;
             
             model.position.x = dragStartModelPos.x + dx;
             model.position.y = dragStartModelPos.y + dy;
             
             // ë“œë˜ê·¸ ì¤‘
           }
         });
         
         document.addEventListener('mouseup', (e) => {
           if (isDraggingCharacter) {
             const movedDistance = Math.sqrt(
               Math.pow(e.clientX - dragStartMousePos.x, 2) + 
               Math.pow(e.clientY - dragStartMousePos.y, 2)
             );
             
             // 5px ì´í•˜ë©´ í´ë¦­ìœ¼ë¡œ ê°„ì£¼ â†’ íƒ­ ëª¨ì…˜
             if (movedDistance < 5) {
               model.motion?.('Tap');
             }
             
             isDraggingCharacter = false;
             dragStartMousePos = null;
             dragStartModelPos = null;
           }
         });

        // ì´ˆê¸°í™” ì™„ë£Œ

        // ëª¨ë¸ ì¤€ë¹„ëœ í›„ ì¸í„°ë™ì…˜ ì œì–´ ë¡œì§ ì„¸íŒ…
        setupInteractionControls();
        
        // ì±„íŒ…/ë¸Œë ˆì¸ìŠ¤í† ë° íŒ¨ë„ ì´ˆê¸°í™”
        setTimeout(() => {
          try {
            if (typeof window.initChatPanel === 'function') {
              window.initChatPanel();
              // ì±„íŒ… íŒ¨ë„ ì´ˆê¸°í™” ì™„ë£Œ
            } else {
              console.warn('âš ï¸  initChatPanel í•¨ìˆ˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„ì‹œ í† ê¸€ ì‚¬ìš©');
              // ì„ì‹œ: ì±„íŒ… í† ê¸€ ë‹¨ì¶•í‚¤ ì§ì ‘ ë“±ë¡
              const chatPanel = document.getElementById('chat-panel');
              if (chatPanel) {
                let isPanelVisible = true;
                window.addEventListener('keydown', (e) => {
                  if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                    isPanelVisible = !isPanelVisible;
                    chatPanel.style.display = isPanelVisible ? 'flex' : 'none';
                    // ì±„íŒ… íŒ¨ë„ í† ê¸€
                  }
                });
                // ì„ì‹œ ì±„íŒ… í† ê¸€ ë“±ë¡ ì™„ë£Œ
              }
            }
          } catch (error) {
            console.error('âŒ ì±„íŒ… íŒ¨ë„ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
          }
          
          try {
            if (typeof window.initBrainstormingPanel === 'function') {
              window.initBrainstormingPanel();
              // ë¸Œë ˆì¸ìŠ¤í† ë° íŒ¨ë„ ì´ˆê¸°í™” ì™„ë£Œ
            } else {
              console.warn('âš ï¸  initBrainstormingPanel í•¨ìˆ˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
          } catch (error) {
            console.error('âŒ ë¸Œë ˆì¸ìŠ¤í† ë° íŒ¨ë„ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
          }
        }, 100); // 100ms ëŒ€ê¸° (ëª¨ë“ˆ ë¡œë”© ì‹œê°„)
        
        // Activity Monitor ì´ˆê¸°í™”
        setupActivityMonitorWithMotions();

      } catch (err) {
        console.error('âŒ ì´ˆê¸°í™” ì‹¤íŒ¨:', err);
        document.getElementById('app').innerHTML =
          `<div style="color:white;padding:20px;font-family:monospace;">
            <h2>âŒ ë¡œë“œ ì‹¤íŒ¨</h2>
            <p>${err.message}</p>
            <p>DevTools â†’ Network/Console í™•ì¸</p>
          </div>`;
      }
    }

    /****************************************************************
     * ì¸í„°ë™ì…˜ ì œì–´
     * - ìºë¦­í„° ë“œë˜ê·¸: ìºë¦­í„° ìœ„ì¹˜ ì´ë™
     * - +/- í‚¤: í¬ê¸° ì¡°ì ˆ
     * - ìºë¦­í„° ë°”ìš´ë”© ë°•ìŠ¤ë§Œ í´ë¦­ ê°€ëŠ¥ (ë™ì  ì¡°ì ˆ)
     * - ì±„íŒ… íŒ¨ë„ì€ ë³„ë„ ì²˜ë¦¬
     ****************************************************************/
    function setupInteractionControls() {
      // setupInteractionControls ì´ˆê¸°í™”
      
      let isDragging = false;
      let lastClientX = 0;
      let lastClientY = 0;

      // í¬ê¸° ì¡°ì ˆ í•¨ìˆ˜
      const adjustScale = (delta) => {
        if (!model) return;
        const step = 0.05;
        let newScale = model.scale.x + delta * step;
        newScale = Math.max(0.1, Math.min(1.0, newScale));
        model.scale.set(newScale);
        // í¬ê¸° ì¡°ì ˆ
      };

      // í‚¤ë³´ë“œë¡œ í¬ê¸° ì¡°ì ˆ ë° ì¢…ë£Œ: +/- í‚¤, ESC í‚¤
      // ì£¼ì˜: Cmd/Ctrl + EnterëŠ” ì±„íŒ… íŒ¨ë„ì—ì„œ ì²˜ë¦¬
      window.addEventListener('keydown', (e) => {
        // ì±„íŒ… ì…ë ¥ì°½ì— í¬ì»¤ìŠ¤ê°€ ìˆì„ ë•ŒëŠ” í¬ê¸° ì¡°ì ˆ ë¹„í™œì„±í™”
        const chatInput = document.getElementById('chat-input');
        if (document.activeElement === chatInput) {
          return; // ì…ë ¥ì°½ì— í¬ì»¤ìŠ¤ê°€ ìˆìœ¼ë©´ ë¬´ì‹œ
        }
        
        if (e.key === '+' || e.key === '=') {
          e.preventDefault();
          adjustScale(1);
        } else if (e.key === '-' || e.key === '_') {
          e.preventDefault();
          adjustScale(-1);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          // ESC í‚¤ - ì•± ì¢…ë£Œ
          if (ipcRenderer) {
            ipcRenderer.send('va:request-quit');
          }
        }
      });

      // ìºë¦­í„° ë“œë˜ê·¸ëŠ” Document ë ˆë²¨ ì´ë²¤íŠ¸ë¡œ ì²˜ë¦¬

      // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬: ì±„íŒ… íŒ¨ë„ vs ìºë¦­í„°
      if (ipcRenderer && model) {
        let isOverCharacter = false;
        let isOverChatPanel = false;
        let isOverBsPanel = false;
        
        const checkIfOverCharacter = (clientX, clientY) => {
          if (!model) return false;
          
          // ìºë¦­í„°ì˜ ì‹¤ì œ ë°”ìš´ë”© ë°•ìŠ¤ ê°€ì ¸ì˜¤ê¸°
          const bounds = model.getBounds();
          
          // Live2D ë°”ìš´ë”© ë°•ìŠ¤ê°€ ì‹¤ì œë³´ë‹¤ ë„“ìœ¼ë¯€ë¡œ ì¢Œìš°ë¥¼ ëŒ€í­ ì¶•ì†Œ
          const actualWidth = bounds.width * 0.4;
          const widthOffset = (bounds.width - actualWidth) / 2;
          const verticalMargin = bounds.height * 0.05;
          
          return clientX >= bounds.x + widthOffset && 
                 clientX <= bounds.x + widthOffset + actualWidth &&
                 clientY >= bounds.y - verticalMargin && 
                 clientY <= bounds.y + bounds.height + verticalMargin;
        };
        
        const checkIfOverChatPanel = (clientX, clientY) => {
          const chatPanel = document.getElementById('chat-panel');
          if (!chatPanel || chatPanel.style.display === 'none') return false;
          
          const rect = chatPanel.getBoundingClientRect();
          return clientX >= rect.left && 
                 clientX <= rect.right && 
                 clientY >= rect.top && 
                 clientY <= rect.bottom;
        };
        
        // ë¸Œë ˆì¸ìŠ¤í† ë° íŒ¨ë„ ì²´í¬ í•¨ìˆ˜
        const checkIfOverBsPanel = (clientX, clientY) => {
          const bsPanel = document.getElementById('brainstorming-panel');
          if (!bsPanel || bsPanel.style.display === 'none') return false;
          
          const rect = bsPanel.getBoundingClientRect();
          return clientX >= rect.left && 
                 clientX <= rect.right && 
                 clientY >= rect.top && 
                 clientY <= rect.bottom;
        };
        
        document.addEventListener('mousemove', (e) => {
          const wasOverChat = isOverChatPanel;
          const wasOverChar = isOverCharacter;
          const wasOverBs = isOverBsPanel;
          
          // ì±„íŒ… íŒ¨ë„ ì²´í¬ (ìš°ì„ ìˆœìœ„ ë†’ìŒ)
          isOverChatPanel = checkIfOverChatPanel(e.clientX, e.clientY);
          
          // ë¸Œë ˆì¸ìŠ¤í† ë° íŒ¨ë„ ì²´í¬ (ìš°ì„ ìˆœìœ„ ë†’ìŒ)
          isOverBsPanel = checkIfOverBsPanel(e.clientX, e.clientY);
          
          // ìºë¦­í„° ì²´í¬ (íŒ¨ë„ë“¤ì´ ì•„ë‹ ë•Œë§Œ)
          if (!isOverChatPanel && !isOverBsPanel) {
            isOverCharacter = checkIfOverCharacter(e.clientX, e.clientY);
          } else {
            isOverCharacter = false;
          }
          
          // ìƒíƒœ ë³€ê²½ ì‹œ IPC ì „ì†¡
          if (wasOverChat !== isOverChatPanel || wasOverChar !== isOverCharacter || wasOverBs !== isOverBsPanel) {
            const shouldAcceptClicks = isOverChatPanel || isOverBsPanel || isOverCharacter;
            const ignoreValue = !shouldAcceptClicks;
            ipcRenderer.send('va:set-ignore-mouse', ignoreValue);
          }
        });
      }
    }

    // ëª¨ë“ˆ ë¡œë”©ì„ ê¸°ë‹¤ë¦¬ê¸° ìœ„í•´ onload ì‚¬ìš©
    window.addEventListener('load', init);
  </script>
</body>
</html>
